/**
 * A model class which represents a type of CAN message.
 * 
 * @author Andrew Mass
 * @version 1.0.3
 */
public class Message {

  /**
   * The message's ID which is sent out on the CAN bus.
   */
  private final String messageId;

  /**
   * Specifies how many SubMessages are contained in this message.
   */
  private final int messageLength;

  /**
   * A collection of the SubMessages contained by this CAN message.
   */
  private final SubMessage[] messageData;

  /**
   * Standard constructor for a Message object.
   * 
   * @param id The message's Id which is sent out on the CAN bus.
   * @param length The length of this message, which specifies how many SubMessages are contained in this message.
   * @param data A collection of the SubMessages contained by this CAN message.
   */
  public Message(String id, int length, SubMessage[] data) {
    this.messageId = id;
    this.messageLength = length;
    this.messageData = data;
  }

  /**
   * Takes all the data bytes for this message and returns a float[] which contains the translated values. This method
   * sends most of the heavy lifting to the SubMessage class, but the timestamp is calculated and added to the array.
   * 
   * @param data Bytes which contain all the SubMessage data sent over the CAN bus.
   * @param time Bytes which contain all the timestamp data for this message.
   * @param numColumns The total number of columns in the main data array for the application.
   * @return A float[] that contains the translated values from this message which will be inserted into the main data
   *         array for the application.
   */
  public float[] translateData(byte[] data, byte[] time, int numColumns) {
    /*
     * The time byte array is four bytes long. The timestamp is generated by concatenating the third and second bytes,
     * adding that to the concatenation of the first and zeroth bytes divided by 0x8000, then subtracting 1.
     */
    float timestamp = ((Integer.parseInt(hex(time[3]) + hex(time[2]), 16) * 1.0f) +
        (((Integer.parseInt(hex(time[1]) + hex(time[0]), 16) * 1.0f) / 32768.0f)) - 1.0f);

    /*
     * Values which are not known to this message (all other columns in the application's main data array), are set to
     * Float.MAX_VALUE during the translation phase to signal to the normalization function that they should not be
     * regarded as data sent in a CAN message.
     */
    float[] values = new float[numColumns];
    for(int i = 0; i < values.length; i++) {
      values[i] = Float.MAX_VALUE;
    }

    values[0] = round(timestamp);

    /*
     * If the messageId is that of the GPS, then handle the data differently.
     */
    if(messageId.equals("0203")) {
      for(int i = 0; i < messageLength / 4; i++) {
        float translatedValue = messageData[i].getValue(data[4 * i], data[(4 * i) + 1], data[(4 * i) + 2],
                                                        data[(4 * i) + 3]);
        values[messageData[i].getColumnIndex()] = (translatedValue == 0.0f) ? translatedValue : round(translatedValue);
      }
      return values;
    }

    /*
     * Iterates through all this message's SubMessages and has them translate the data sent over the CAN bus into the
     * intended values. The messageLength ensures that we don't go out of the range of the data[] array. Two consecutive
     * bytes from the data[] are sent to each SubMessage.
     */
    for(int i = 0; i < messageLength / 2; i++) {
      if(!(messageData[i].getTitle().equals("Rsrvd") || messageData[i].getTitle().equals("Unused"))) {
        float translatedValue = messageData[i].getValue(data[2 * i], data[(2 * i) + 1]);
        values[messageData[i].getColumnIndex()] = (translatedValue == 0.0f) ? translatedValue : round(translatedValue);
      }
    }
    return values;
  }

  /**
   * Formats the number to a specific number of significant figures
   * 
   * @param num The number to format
   * @return A formatted string representation of the number.
   */
  private float round(float num) {
    final int SIG_FIGS = 6;

    if(num == 0.0f) {
      return 0.0f;
    }

    final double d = Math.ceil(Math.log10(num < 0 ? -num : num));
    final int power = SIG_FIGS - (int) d;

    final double magnitude = Math.pow(10, power);
    final long shifted = Math.round(num * magnitude);
    return Float.parseFloat("" + shifted / magnitude);
  }

  /**
   * Takes the byte input and returns a String representation in hex.
   * 
   * @param num A number in the form of a byte object.
   * @return A string representation of num in hex format.
   */
  public String hex(byte num) {
    return String.format("%02x", num);
  }

  public int getLength() {
    return this.messageLength;
  }

  public String getMessageId() {
    return this.messageId;
  }

  public SubMessage[] getSubMessages() {
    return this.messageData;
  }
}
